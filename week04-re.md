# 正規表現

## 正規表現とは

>正規表現（せいきひょうげん、英: regular expression）とは、文字列の集合を一つの文字列で表現する方法の一つである。-正規表現 - Wikipedia

例として、入力された文字列が「携帯電話の番号」か判定する状況を想定する。

ここで携帯電話の番号は、XXX-XXXX-XXXXの形式をとるものとする。

数字が3,4,4の長さであり、「-」で区切られている必要がある。

これを正規表現で判定するには、以下の文字列が用いられる。

```python
'[0-9]{3}-[0-9]{4}-[0-9]{4}'
```

もしくは

```python
'\d{3}-\d{4}-\d{4}'
```

（他にもやり方は存在すると思うが、きりがないので省略）

## Pythonにて正規表現を利用する

ここからは、実際にPythonにおいてどのようにして正規表現を利用できるのか説明する。

XXX-XXXX-XXXXの形式であるか判定する

```python
import re
# 判定する文字列
ts = ['090', '090-1234', '09012345678', '090-1234-5678']
# 正規表現
r = r'\d{3}-\d{4}-\d{4}'
for t in ts:
    # 実際に利用
    print('{}: {}'.format(t, re.findall(r, t)))
```

実行結果

```none
090: []
090-1234: []
09012345678: []
090-1234-5678: ['090-1234-5678']
```

**正規表現は、`r'xxxxx'`のように、`r''`で生の文字列とする必要がある。**

`re.findall(reg, str)`は、正規表現に当てはまる文字列すべてをリストにして返す

```python
r = r'\d{3}'
```

に変更して実行した結果

```none
090: ['090']
090-1234: ['090', '123']
09012345678: ['090', '123', '456']
090-1234-5678: ['090', '123', '567']
```

## 正規表現を求めるには

では、どのようにして正規表現を求めるのか。

既に気付いているかもしれないが、`\d`は0~9の数字を、`{n}`はn回連続を、示している。

より詳しく、より多くの「どのキーワードがどのような意味を持つのか」を知るには、ドキュメントを参照してほしい。

ドキュメントを参照する癖をつけてほしいため。~~決して、面倒だからではない。~~

[6.2. re — 正規表現操作 — Python 3.6.5 ドキュメント
](https://docs.python.jp/3/library/re.html)

## 演習

### Ex1

```python
t = """
abcdefg
0123456
"""
```

`re.match()`を使い、`a～6`を取得しなさい。ただし、1つの文字列として取得すること。

#### Hint1-1

すべてを取得するときは、`.*`が手っ取り早い。

`.`は、どんな文字でもよく、`*`は、繰り返しを意味する。

#### Hint1-2

`re.match()`を使用した結果、返却されるのは、文字列ではない。メソッドの`group()`を利用しよう。

#### Hint1-3

改行が含まれていてもまとめて取得できるようにするには、何が必要なのだろうか。`match()`の引数オプションを調べてみよう。

### Ex2

四則演算(+,-,*,/)の式を判別できるようにしなさい。

以下の文字列を与えたとき、実行結果と同じ判別（True, False）ができるようにしなさい。

また、可能であれば、実行結果と全く同じ表示にしなさい。

```python
tests = [
    '1+1', '2-3', '4*5', '6/7',
    '88+99', '100-10', '999*1030', '2056',
    '+', '-1', '0*', '//',
    'a+1', 'b-c', 'd**2', 'edf',
    '900+1090+1124', '100/90/105', '-100+200',
    '*151+213', '4*7*8', '100+a-100', '100-50-21',
    '-10-10-10-10', '-20+40*10/50-30'
]
```

実行結果

```none
1+1            : 1+1             ===> True
2-3            : 2-3             ===> True
4*5            : 4*5             ===> True
6/7            : 6/7             ===> True
88+99          : 88+99           ===> True
100-10         : 100-10          ===> True
999*1030       : 999*1030        ===> True
2056           :                 ===> False
+              :                 ===> False
-1             :                 ===> False
0*             :                 ===> False
//             :                 ===> False
a+1            :                 ===> False
b-c            :                 ===> False
d**2           :                 ===> False
edf            :                 ===> False
900+1090+1124  : 900+1090+1124   ===> True
100/90/105     : 100/90/105      ===> True
-100+200       : -100+200        ===> True
*151+213       :                 ===> False
4*7*8          : 4*7*8           ===> True
100+a-100      :                 ===> False
100-50-21      : 100-50-21       ===> True
-10-10-10-10   : -10-10-10-10    ===> True
-20+40*10/50-30: -20+40*10/50-30 ===> True
```

#### Hint2-1

考えるべきポイントは、正規表現のみである。まずは、ドキュメント等を見ながら、どのようにすれば、`1+1や2-3`が取得できるのか考える。

#### Hint2-2

「`+, -, *, /`の**いずれか**をとる」には、「`|`」が有効である。

#### Hint2-3

被演算子は、2つとは限らない。3つでも4つでも5つでもいいようにする必要がある。`()`を使うことで、`()でくくった部分全体`を繰り返しなどに利用することができる。

### Ex3

Ex2の文字列testsを使用する。

すべての演算子を取得しなさい。また、演算子を`replace()`を使わずに、「@」に置換しなさい。

#### Ex3-1

**すべて**取得するには、`match()`を使うのか？`search()`？`find()`？

#### Ex3-2

reモジュールに、置換用の関数が存在する。調査せよ。

### Ex4

以下の文字列から、実行結果のように「```」で挟まれた部分のみを抽出しなさい。文字列の頭のほうから順に調べるものとする。

<pre><code>
"""
codeblock!!before
```
abcdefghijk
01234567890
codeblock!!
```
codeblock!!after
```
no!!codeblock!!
"""
</code></pre>

実行結果

<pre><code>
```
abcdefghijk
01234567890
codeblock!!
```
</code></pre>

#### Hint4-1

`match()`には、ある特性があり、本問題に使用するとうまくいかなくなる。その特性を調べるとともに、本問題で使用できる関数を探そう。

#### Hint4-2

今までの繰り返しを使用すると、`codeblock!!after`まで含んでしまう。

含まないようにするには、何が必要だろうか？

[TOPへ戻る](./index.md)
